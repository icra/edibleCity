---
title: "ediblecity R package - example"
author: "Josep Pueyo-Ros"
date: "28/9/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
```


#### LOADING LIBRARIES AND DATA

```{r init, echo=FALSE, message=FALSE}
suppressWarnings(library(ediblecity))
suppressWarnings(library(tidyverse))
suppressWarnings(library(stars))
suppressWarnings(library(patchwork))
set.seed(1119)

ggplot(city_example)+
  geom_sf()+
  geom_sf(data= filter(city_example, Function %in% city_functions$functions[city_functions$edible]), aes(color=Function))
```

### DEFINING SCENARIO S3.50

The function 'set_scenario' converts parts of the city in urban agriculture initiatives according to defined parameters in the the function.  

```{r scenario}
full <- set_scenario(city_example,
                     pGardens = 1,
                     pVacant = 1,
                     pRooftop = 1,
                     perc_garden = c(0.02, 0.3),
                     perc_vacant = c(0.52, 0.75),
                     perc_rooftop = c(0.6, 0.62),
                     min_area_garden = 10,
                     min_area_vacant = 100,
                     min_area_rooftop = 100,
                     private_gardens_from = "Normal garden",
                     vacant_from = "Vacant",
                     rooftop_from = "Rooftop",
                     pCommercial = 0.25,
                     area_field = "flat_area"
             )
for (f in city_functions$functions[city_functions$edible]){
  print(paste(f,"=", sum(full$Function == f)))
}

ggplot()+
  geom_sf(data=full)+
  geom_sf(data= filter(full, Function %in% city_functions$functions[city_functions$edible]), aes(color=Function))
```

### ESTIMATION OF JOBS CREATED BY URBAN AGRICULTURE

The jobs are a function of the surface used for commercial gardens and rooftops to grow up plants. It simulates a random uniform distribution based on the range provided and returns the 95% confidence interval.

```{r edible_jobs}
edible_jobs(  
  full,
  jobs = c(0.000163, 0.022),
  area_col = "flat_area",
  interval = 0.95)


```
### ESTIMATION OF VOLUNTEERS INVOLVED IN URBAN AGRICULTURE

The number of volunteers is a function of the surface used for commercial gardens and rooftops to grow up plants. It simulates a random uniform distribution based on the range provided and returns the 95% confidence interval.

```{r edible_volunteers}
edible_volunteers(  
  full,
  volunteers = c(0.00163, 0.22),
  area_col = "flat_area",
  interval = 0.95)
```
### ESTIMATION OF GREEN PER CAPITA

The function calculates the amount of green surface in the city (edible and non-edible) and divides per inhabitants. It can calculate the value per neighbourhood as well as the proportion between the greenest neighbourhood and the least green one.

#### BASE SCENARIO
```{r green_capita_base}
# Green per capita in m2
base_m2 <- green_capita(city_example, inhabitants = 44474, private = F)
# Ratio of green per capita between highest and lowest neighbourhood
base_p <- green_capita(city_example, 
             neighbourhoods = neighbourhoods, 
             name_col = 'name',
             inh_col = 'inhabitants',
             verbose = F,
             min_inh = 300,
             private = T)
#Values by neighbourhood
base_table <- green_capita(city_example, 
             neighbourhoods = neighbourhoods, 
             name_col = 'name',
             inh_col = 'inhabitants',
             verbose = T, 
             private = F)

#Green per capita in the whole city
base_m2

#Proportion between extreme values in neihbourhoods
base_p

base_table

```

#### FULL SCENARIO
```{r green_capita_full}
# Green per capita in m2
full_m2 <- green_capita(full, inhabitants = 44474, private = F)
# Ratio of green per capita between highest and lowest neighbourhood
full_p <- green_capita(full, 
             neighbourhoods = neighbourhoods, 
             name_col = 'name',
             inh_col = 'inhabitants',
             verbose = F,
             min_inh = 300, 
             private = F)
#Values by neighbourhood
full_table <- green_capita(full, 
             neighbourhoods = neighbourhoods, 
             name_col = 'name',
             inh_col = 'inhabitants',
             verbose = T,
             private = F)

#Green per capita in the whole city
full_m2

#Proportion between extreme values in neihbourhoods
full_p
full_table

```

```{r green_capita_plot, echo=F}

full_join(base_table, full_table, by='name') %>%
  filter(inhabitants.x > 300) %>% 
  select(name, starts_with("green_capita")) %>% 
  pivot_longer(cols=starts_with("green"), names_to = "scenario") %>%
  mutate(scenario = ifelse(scenario=="green_capita.x", "Base scenario", "Full scenario")) %>% 
  ggplot(aes(name, value,fill=scenario))+
    geom_bar(stat="identity",position="dodge")+
    theme(axis.text.x = element_text(angle=90, vjust = 0.5, hjust=1))

```

### DISTANCE TO GREEN

Thisi indicator calculates the distance from each residence to its closest public green area larger than 'min_area'. It can return the summary of distances or the percentage of residence buildings further than a defined distance.

#### BASE SCENARIO
```{r green_distance base}

#Distance to closest public green area
base_summary <- green_distance(city_example,
                               min_area = 5000,
                               percent_out = F,
                               max_dist = 300,
                               verbose = F)

#Percentage of houses further than 300 meters
base_percent <- green_distance(city_example,
                               min_area = 5000,
                               percent_out = T,
                               max_dist = 300,
                               verbose = F)

#All distances
base_dist <- green_distance(city_example,
                               min_area = 5000,
                               percent_out = T,
                               max_dist = 300,
                               verbose = T)

```

#### FULL SCENARIO
```{r green_distance full, message=F}

#Distance to closest public green area
full_summary <- green_distance(full,
                               min_area = 5000,
                               percent_out = F,
                               max_dist = 300,
                               verbose = F)

#Percentage of houses further than 300 meters
full_percent <- green_distance(full,
                               min_area = 5000,
                               percent_out = T,
                               max_dist = 300,
                               verbose = F)

#All distances
full_dist <- green_distance(full,
                               min_area = 5000,
                               percent_out = T,
                               max_dist = 300,
                               verbose = T)
base_summary
full_summary

base_percent
full_percent

colors <- c("Base scenario" = rgb(5,34,255,125, maxColorValue = 255), 
            "Full scenario" = rgb(245,72,66, 125, maxColorValue = 255))

data.frame(base = as.numeric(base_dist), full = as.numeric(full_dist)) %>% 
  ggplot()+
    geom_histogram(aes(base, fill = "Base scenario"))+
    geom_histogram(aes(full, fill = 'Full scenario'))+
    scale_fill_manual(values = colors)
```

### URBAN HEAT ISLAND

The indicator calculates de urban heat island (UHI) following Theeuwes, N. E., Steeneveld, G. J., Ronda, R. J., & Holtslag, A. A. M. (2017). A diagnostic equation for the daily maximum urban heat island effect for cities in northwestern Europe. International Journal of Climatology, 37(1), 443-454. https://doi.org/10.1002/joc.4717

#### BASE SCENARIO

```{r UHI}

SVF <- stars::read_stars("../ediblecity_sim/SVF_3035.tif")

uhi <- UHI(city_example, SVF = SVF, return_raster = T)
uhi2 <- UHI(full, SVF = SVF, return_raster = T)

names(uhi) <- "Base"
names(uhi2) <- "Full"

p_custom <- theme_set(theme_void())+
  theme(axis.ticks = element_blank(), axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank())


rast_plot <- function(raster){  
  return(ggplot()+
          geom_stars(data = raster)+
          scale_fill_gradient(low="lightblue", high = "tomato", na.value = "white")+
          coord_equal()+
          theme_void())
}
  
p1 <- rast_plot(uhi)
p2 <- rast_plot(uhi2)

stars_sum <- function(x){return(summary(dplyr::as_tibble(x)[[3]]))}
cat("Base scenario\n")
stars_sum(uhi)
cat("Full scenario\n")
stars_sum(uhi2)

p1 + p2

```

### NO2 SEQUESTRATION

This indicator returns the amount of NO2 that is sequestered by urban green.

```{r NO2_seq}

no2_base <- no2_seq(city_example)
no2_full <- no2_seq(full)

cat("NO2 sequestration in base scenario\n")
no2_base
cat("NO2 sequestration in full scenario\n")
no2_full

```

### FOOD PRODUCTION

This indicator estimates the food (in kg/year) produced by urban agriculture initiatives in your city. It uses a range of production for each type of initiative to create the median and the confidence interval of the number of jobs by simulating a random uniform distribution of 1000 values within the provided range.

```{r food_production}

food_base <- food_production(city_example)
food_full <- food_production(full)
consumption <- 44474*73

cat("Ratio of consumption vs production\n")
cat("\nBase scenario\n")
round(food_base / consumption, 3)
cat("\nFull scenario\n")
round(food_full / consumption, 3)

```

```{r runoff_prevention}

#runoff prevention

runoff_base <- runoff_prev(city_example)
runoff_full <- runoff_prev(full)

text <- paste0("Runoff prevented in base scenario = ", round(runoff_base[[1]],3),"\n",
                "Runoff prevented in full scenario = ", round(runoff_full[[1]],3))

tibble(results = c("runoff_prev", names(runoff_full)[-1]),
       runoff_base, runoff_full) %>%
  filter(results != "rainfall" & results!= "runoff_prev") %>% 
  pivot_longer(cols=starts_with("runoff")) %>% 
  ggplot(aes(x=results, y= value, fill=name))+
    geom_bar(stat = "identity", position = position_dodge2())+
    annotate(x=1.5, y=90000, geom = "text", label = text)+
    labs(y= "cubic metres")+
    theme_grey()

```
